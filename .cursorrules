# ğŸ¯ Remote Server Control - Cursor Rules

## ğŸ“‹ VisÃ£o Geral do Projeto

Este Ã© um projeto **open-source** e **multiplataforma** de CLI para gerenciamento de serviÃ§os remotos. O foco estÃ¡ em:
- **Multiplataforma**: Funciona em Linux, macOS e Windows
- **Open Source**: FÃ¡cil de contribuir, bem documentado
- **Robustez**: Tratamento de erros completo, validaÃ§Ãµes, retry logic
- **Escalabilidade**: Arquitetura modular, extensÃ­vel, plugin-ready
- **Performance**: Cache inteligente, operaÃ§Ãµes assÃ­ncronas quando possÃ­vel
- **UX/DevEx**: Interface clara, feedback rico, documentaÃ§Ã£o completa
- **Qualidade**: Testes, type hints, linting, CI/CD

## ğŸ—ï¸ Arquitetura

### Estrutura de DiretÃ³rios

```
cli/
â”œâ”€â”€ rsctl.py              # Entry point principal
â”œâ”€â”€ src/                  # CÃ³digo fonte modular
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ core/             # Core functionality
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ manager.py    # ServiceManager principal
â”‚   â”‚   â”œâ”€â”€ config.py     # Gerenciamento de configuraÃ§Ã£o
â”‚   â”‚   â”œâ”€â”€ cache.py      # Sistema de cache
â”‚   â”‚   â””â”€â”€ validator.py  # ValidaÃ§Ãµes
â”‚   â”œâ”€â”€ services/         # ImplementaÃ§Ãµes de serviÃ§os
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py       # Classe base abstrata
â”‚   â”‚   â”œâ”€â”€ ssh.py
â”‚   â”‚   â”œâ”€â”€ docker.py
â”‚   â”‚   â””â”€â”€ systemd.py
â”‚   â”œâ”€â”€ utils/            # UtilitÃ¡rios
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ logger.py     # Sistema de logging
â”‚   â”‚   â”œâ”€â”€ colors.py     # Cores e formataÃ§Ã£o
â”‚   â”‚   â”œâ”€â”€ exceptions.py # ExceÃ§Ãµes customizadas
â”‚   â”‚   â””â”€â”€ helpers.py    # FunÃ§Ãµes auxiliares
â”‚   â””â”€â”€ cli/              # Interface CLI
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ commands.py   # Comandos CLI
â”‚       â””â”€â”€ parser.py     # Argument parsing
â”œâ”€â”€ tests/                # Testes
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ fixtures/
â”œâ”€â”€ config/               # ConfiguraÃ§Ãµes
â”‚   â”œâ”€â”€ services.json
â”‚   â””â”€â”€ defaults.json
â””â”€â”€ scripts/              # Scripts auxiliares
```

## ğŸ¨ PadrÃµes de CÃ³digo

### Python

- **Type Hints**: Sempre usar type hints completos
- **Docstrings**: Google style docstrings em todas as funÃ§Ãµes/classes pÃºblicas
- **Error Handling**: Usar exceÃ§Ãµes customizadas, nunca silenciar erros
- **Logging**: Usar logging module, nunca print() para logs
- **Async**: Considerar async/await para operaÃ§Ãµes I/O quando apropriado
- **Testing**: Cobertura mÃ­nima de 80%, testes unitÃ¡rios e de integraÃ§Ã£o

### Exemplo de Classe

```python
from typing import Optional, Dict, List
import logging

logger = logging.getLogger(__name__)

class ServiceManager:
    """
    Gerencia serviÃ§os do servidor remoto.
    
    Attributes:
        config: ConfiguraÃ§Ã£o carregada dos serviÃ§os
        cache: Sistema de cache para otimizaÃ§Ã£o
    """
    
    def __init__(self, config_path: Optional[Path] = None) -> None:
        """Inicializa o gerenciador de serviÃ§os.
        
        Args:
            config_path: Caminho opcional para arquivo de configuraÃ§Ã£o
            
        Raises:
            ConfigError: Se a configuraÃ§Ã£o for invÃ¡lida
        """
        self.config = self._load_config(config_path)
        self.cache = CacheManager()
        logger.info("ServiceManager inicializado")
    
    def start_service(self, service_name: str, timeout: int = 30) -> bool:
        """Inicia um serviÃ§o especÃ­fico.
        
        Args:
            service_name: Nome do serviÃ§o a iniciar
            timeout: Timeout em segundos para operaÃ§Ã£o
            
        Returns:
            True se o serviÃ§o foi iniciado com sucesso
            
        Raises:
            ServiceNotFoundError: Se o serviÃ§o nÃ£o existe
            ServiceStartError: Se falhar ao iniciar
        """
        # ImplementaÃ§Ã£o
```

## ğŸ” ValidaÃ§Ãµes e Tratamento de Erros

### Sempre Validar

1. **Input do usuÃ¡rio**: Validar argumentos CLI
2. **ConfiguraÃ§Ã£o**: Validar JSON de configuraÃ§Ã£o
3. **DependÃªncias**: Verificar se comandos/tools existem
4. **PermissÃµes**: Verificar permissÃµes antes de executar
5. **Estado**: Verificar estado atual antes de operaÃ§Ãµes

### ExceÃ§Ãµes Customizadas

```python
# utils/exceptions.py
class RSCTLError(Exception):
    """Base exception para rsctl"""
    pass

class ConfigError(RSCTLError):
    """Erro de configuraÃ§Ã£o"""
    pass

class ServiceNotFoundError(RSCTLError):
    """ServiÃ§o nÃ£o encontrado"""
    pass

class ServiceStartError(RSCTLError):
    """Erro ao iniciar serviÃ§o"""
    pass
```

### Retry Logic

Sempre implementar retry com backoff exponencial para operaÃ§Ãµes de rede/I/O:

```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=2, max=10)
)
def check_service_health(self, service_name: str) -> bool:
    # ImplementaÃ§Ã£o com retry
```

## ğŸ“Š Logging

### Estrutura de Logging

```python
import logging
from logging.handlers import RotatingFileHandler

# Configurar logger
logger = logging.getLogger('rsctl')
logger.setLevel(logging.DEBUG)

# Handler para arquivo
file_handler = RotatingFileHandler(
    'logs/rsctl.log',
    maxBytes=10*1024*1024,  # 10MB
    backupCount=5
)
file_handler.setFormatter(
    logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
)

# Handler para console (apenas INFO+)
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(CustomFormatter())

logger.addHandler(file_handler)
logger.addHandler(console_handler)
```

### NÃ­veis de Log

- **DEBUG**: InformaÃ§Ãµes detalhadas para debugging
- **INFO**: OperaÃ§Ãµes normais (start, stop, status)
- **WARNING**: SituaÃ§Ãµes que podem causar problemas
- **ERROR**: Erros que nÃ£o impedem execuÃ§Ã£o
- **CRITICAL**: Erros que impedem execuÃ§Ã£o

## âš¡ Performance

### Cache

- Cache de status de serviÃ§os (TTL: 5 segundos)
- Cache de configuraÃ§Ã£o (atÃ© reload manual)
- Cache de resultados de comandos (TTL: 2 segundos)

### OtimizaÃ§Ãµes

- Verificar status em paralelo quando possÃ­vel
- Usar comandos eficientes (ex: `docker ps --format` vs `docker ps | grep`)
- Timeouts apropriados para evitar hangs
- Lazy loading de configuraÃ§Ãµes pesadas

## ğŸ§ª Testes

### Estrutura

- **Unit Tests**: Testar funÃ§Ãµes isoladamente
- **Integration Tests**: Testar interaÃ§Ã£o entre componentes
- **Mocking**: Mockar subprocess, filesystem, network

### Exemplo

```python
import pytest
from unittest.mock import Mock, patch
from rsctl.core.manager import ServiceManager

class TestServiceManager:
    @pytest.fixture
    def manager(self):
        return ServiceManager()
    
    @patch('rsctl.core.manager.subprocess.run')
    def test_start_service_success(self, mock_run, manager):
        mock_run.return_value = Mock(returncode=0)
        assert manager.start_service('ssh') is True
```

## ğŸ“ DocumentaÃ§Ã£o

### Docstrings

- Sempre documentar classes pÃºblicas
- Documentar parÃ¢metros, retornos, exceÃ§Ãµes
- Incluir exemplos quando apropriado

### README

- Manter README atualizado
- Incluir exemplos de uso
- Documentar configuraÃ§Ãµes avanÃ§adas

## ğŸ”§ Ferramentas de Desenvolvimento

### Pre-commit Hooks

- black (formataÃ§Ã£o)
- flake8 (linting)
- mypy (type checking)
- pytest (testes)

### Makefile

Criar Makefile com comandos comuns:
- `make test`: Rodar testes
- `make lint`: Verificar cÃ³digo
- `make format`: Formatar cÃ³digo
- `make install`: Instalar CLI

## ğŸš€ Quando Adicionar Novos Recursos

1. **Planejar**: Documentar design antes de implementar
2. **Multiplataforma**: Considerar compatibilidade com todas plataformas
3. **Testar**: Escrever testes primeiro (TDD quando possÃ­vel)
4. **Validar**: Validar input e estado
5. **Logar**: Adicionar logs apropriados
6. **Documentar**: Atualizar documentaÃ§Ã£o (incluindo PLATAFORMAS.md se necessÃ¡rio)
7. **Revisar**: Code review antes de merge

## ğŸ¤ Open Source

### Ao Contribuir

- Sempre considerar mÃºltiplas plataformas
- Documentar limitaÃ§Ãµes (se houver)
- Adicionar testes quando possÃ­vel
- Atualizar documentaÃ§Ã£o relevante
- Seguir padrÃµes de cÃ³digo do projeto

## ğŸ¯ Prioridades

1. **Robustez** > Features: Melhor ter menos features que funcionam bem
2. **Clareza** > Cleverness: CÃ³digo claro Ã© melhor que cÃ³digo "esperto"
3. **Performance** > Prematuro: Otimizar apenas quando necessÃ¡rio
4. **Testes** > PerfeiÃ§Ã£o: Testes sÃ£o mais importantes que cÃ³digo perfeito

## ğŸŒ Multiplataforma

### Sempre Considerar

1. **DetecÃ§Ã£o de Plataforma**: Usar `PlatformDetector` para detectar OS
2. **Comandos Adaptativos**: Usar comandos apropriados por plataforma
3. **Caminhos**: Sempre usar `pathlib.Path` para compatibilidade
4. **Sudo**: Apenas em Unix-like (Linux/macOS), nÃ£o em Windows
5. **Testar**: Testar em mÃºltiplas plataformas quando possÃ­vel

### Exemplo de CÃ³digo Multiplataforma

```python
from src.utils.platform import PlatformDetector

if PlatformDetector.is_windows():
    # CÃ³digo Windows
    cmd = ["netstat", "-an"]
elif PlatformDetector.is_macos():
    # CÃ³digo macOS
    cmd = ["lsof", "-i", f":{port}"]
else:
    # CÃ³digo Linux
    cmd = ["ss", "-lntp"]
```

### Comandos por Plataforma

| Funcionalidade | Linux | macOS | Windows |
|----------------|-------|-------|---------|
| Verificar porta | `ss -lntp` | `lsof -i :port` | `netstat -an` |
| Verificar processo | `pgrep -f` | `pgrep -f` | `tasklist` |
| Gerenciar serviÃ§os | `systemctl` | `launchctl` | `sc` / PowerShell |
| Sudo | `sudo` | `sudo` | NÃ£o necessÃ¡rio |

## ğŸ” SeguranÃ§a

- Nunca executar comandos nÃ£o validados
- Validar todos os inputs do usuÃ¡rio
- Usar subprocess com shell=False quando possÃ­vel
- Sanitizar output antes de exibir
- NÃ£o logar informaÃ§Ãµes sensÃ­veis (senhas, tokens)
- Considerar permissÃµes por plataforma (sudo vs UAC)

## ğŸ“¦ DependÃªncias

- Manter dependÃªncias mÃ­nimas
- Usar versÃµes especÃ­ficas (requirements.txt)
- Documentar por que cada dependÃªncia Ã© necessÃ¡ria
- Atualizar regularmente para seguranÃ§a

## ğŸŒ InternacionalizaÃ§Ã£o (Futuro)

- Preparar strings para i18n
- Usar constantes para mensagens
- Considerar gettext no futuro
